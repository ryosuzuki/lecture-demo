<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Language Model Demo (Single-file 1/2-gram)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.5;
    }
    h1 { font-size: 20px; margin: 0 0 12px; }
    h2 { font-size: 16px; margin: 18px 0 8px; }
    .grid {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
    textarea {
      width: 100%;
      min-height: 180px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(128,128,128,0.4);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans Mono", monospace;
      font-size: 13px;
      box-sizing: border-box;
    }
    .card {
      border: 1px solid rgba(128,128,128,0.35);
      border-radius: 14px;
      padding: 12px;
      background: rgba(128,128,128,0.06);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    label { font-size: 13px; opacity: 0.9; }
    select, input[type="number"], input[type="file"] {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(128,128,128,0.4);
      background: transparent;
    }
    button {
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(128,128,128,0.45);
      background: rgba(128,128,128,0.12);
      cursor: pointer;
    }
    button:hover { filter: brightness(1.05); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .muted { font-size: 12px; opacity: 0.75; }
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 13px;
    }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(128,128,128,0.35);
      background: rgba(128,128,128,0.10);
      font-size: 12px;
    }
    .sentenceBox {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans Mono", monospace;
      font-size: 14px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(128,128,128,0.35);
      background: rgba(128,128,128,0.06);
      min-height: 44px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .options {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }
    .opt {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 10px;
      align-items: center;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(128,128,128,0.35);
      background: rgba(128,128,128,0.08);
    }
    .opt button {
      width: 100%;
      border-radius: 10px;
      padding: 8px 10px;
    }
    .bar {
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(128,128,128,0.35);
      overflow: hidden;
      background: rgba(128,128,128,0.08);
      position: relative;
    }
    .bar > div {
      height: 100%;
      width: 0%;
      background: rgba(100,160,255,0.45);
    }
    .prob {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.85;
      margin-top: 6px;
      gap: 10px;
    }
    details summary { cursor: pointer; }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid rgba(128,128,128,0.25);
      padding: 6px 4px;
      text-align: left;
      vertical-align: top;
    }
    code.k { padding: 2px 6px; border-radius: 8px; background: rgba(128,128,128,0.12); }
  </style>
</head>

<body>
  <h1>Mini Language Model Demo (single-file / unigram & bigram)</h1>

  <div class="grid">
    <div class="card">
      <h2>1) Training data (each line = one sentence)</h2>

      <div class="row" style="margin-bottom: 8px;">
        <label for="fileInput">Load .txt:</label>
        <input id="fileInput" type="file" accept=".txt,text/plain" />
        <button id="trainBtn">Train</button>
      </div>

      <textarea id="trainText"></textarea>

      <div class="row" style="margin-top: 10px;">
        <label>Tokenization:</label>
        <select id="tokenizeMode">
          <option value="regex">Simple (split punctuation too)</option>
          <option value="space">Space-separated</option>
          <option value="char">Character-level</option>
        </select>

        <label>Model:</label>
        <select id="modelType">
          <option value="bigram">Bigram (previous token → next token)</option>
          <option value="unigram">Unigram (no context)</option>
        </select>
      </div>

      <div class="row" style="margin-top: 10px;">
        <label>Top-K candidates:</label>
        <input id="topK" type="number" min="1" max="200" value="30" style="width: 90px;" />
        <label><input id="lowercase" type="checkbox" checked /> Lowercase</label>
        <span class="muted">(Adds <code class="k">&lt;s&gt;</code> and <code class="k">&lt;/s&gt;</code>)</span>
      </div>

      <div style="margin-top: 12px;" class="stats">
        <div>Status: <span class="pill" id="statusPill">Not trained</span></div>
        <div>Vocabulary: <span class="pill" id="vocabPill">-</span></div>
        <div>Total tokens: <span class="pill" id="tokenPill">-</span></div>
        <div>Bigram types: <span class="pill" id="bigramPill">-</span></div>
      </div>

      <details style="margin-top: 12px;">
        <summary>Peek into the model (top transitions)</summary>
        <div class="muted" style="margin: 8px 0 6px;">
          For bigrams, this shows next-token distributions given the previous token (top only).
        </div>
        <div id="modelPeek"></div>
      </details>
    </div>

    <div class="card">
      <h2>2) Build a sentence by choosing the next token</h2>

      <div class="row">
        <button id="resetBtn" disabled>Reset</button>
        <button id="undoBtn" disabled>Undo</button>
        <button id="randomBtn" disabled>Pick random</button>
        <label>Max length:</label>
        <input id="maxLen" type="number" min="1" max="500" value="30" style="width: 90px;" />
      </div>

      <div style="margin-top: 10px;" class="muted">
        Current context (previous token): <span class="pill" id="contextPill">-</span>
      </div>

      <div style="margin-top: 10px;">
        <div class="muted">Generated sentence:</div>
        <div class="sentenceBox" id="sentenceBox">(not started)</div>
      </div>

      <div style="margin-top: 12px;">
        <div class="muted">Next-token candidates (click to append):</div>
        <div class="options" id="options"></div>
        <div class="muted" id="noOptions" style="margin-top: 10px; display:none;">
          No candidates available. Add more training data or change context (Undo/Reset).
        </div>
      </div>

      <div class="muted" style="margin-top: 12px;">
        Notes:
        <ul style="margin: 6px 0 0 18px;">
          <li><strong>Bigram:</strong> next-token distribution depends on the previous token.</li>
          <li><strong>Unigram:</strong> next token depends only on overall frequency.</li>
          <li>Select <code class="k">&lt;/s&gt;</code> to end a sentence; context resets to <code class="k">&lt;s&gt;</code>.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const trainText = $("trainText");
  const tokenizeMode = $("tokenizeMode");
  const modelTypeSel = $("modelType");
  const trainBtn = $("trainBtn");
  const topKInput = $("topK");
  const lowercaseChk = $("lowercase");
  const fileInput = $("fileInput");

  const statusPill = $("statusPill");
  const vocabPill = $("vocabPill");
  const tokenPill = $("tokenPill");
  const bigramPill = $("bigramPill");
  const modelPeek = $("modelPeek");

  const resetBtn = $("resetBtn");
  const undoBtn = $("undoBtn");
  const randomBtn = $("randomBtn");
  const maxLenInput = $("maxLen");
  const contextPill = $("contextPill");
  const sentenceBox = $("sentenceBox");
  const optionsDiv = $("options");
  const noOptions = $("noOptions");

  const START = "<s>";
  const END = "</s>";

  const DEFAULT_SAMPLE =
`I like machine learning.
I like natural language processing.
I like generative AI.
We build simple language models.
Language models predict the next word.
Students like interactive demos.
This demo is a tiny n-gram model.
Generative models can sample tokens.
Probability distributions can be visualized.
I like teaching in class.`;

  let trained = false;

  let unigramCounts = Object.create(null);
  let bigramCounts = Object.create(null);

  let generated = [];
  let context = START;

  function clampInt(v, min, max, fallback) {
    const n = Number.parseInt(v, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return fallback;
  }

  function normalizeText(s) {
    let t = s.replace(/\r\n?/g, "\n");
    if (lowercaseChk.checked) t = t.toLowerCase();
    return t;
  }

  function tokenizeLine(line, mode) {
    const s = line.trim();
    if (!s) return [];

    if (mode === "space") return s.split(/\s+/).filter(Boolean);
    if (mode === "char") return Array.from(s.replace(/\s+/g, ""));

    const re = /[\p{L}\p{N}]+|[^\s\p{L}\p{N}]/gu;
    const m = s.match(re);
    return (m || []).filter(tok => tok.trim() !== "");
  }

  function trainFromText(text) {
    unigramCounts = Object.create(null);
    bigramCounts = Object.create(null);

    const mode = tokenizeMode.value;
    const lines = normalizeText(text).split("\n");

    let totalTokens = 0;
    let totalBigramTypes = 0;

    for (const lineRaw of lines) {
      const toks = tokenizeLine(lineRaw, mode);
      if (toks.length === 0) continue;

      const seq = [START, ...toks, END];

      for (const tok of seq) {
        unigramCounts[tok] = (unigramCounts[tok] || 0) + 1;
        totalTokens++;
      }

      for (let i = 0; i < seq.length - 1; i++) {
        const prev = seq[i];
        const next = seq[i + 1];
        if (!bigramCounts[prev]) bigramCounts[prev] = Object.create(null);
        bigramCounts[prev][next] = (bigramCounts[prev][next] || 0) + 1;
      }
    }

    for (const prev of Object.keys(bigramCounts)) {
      totalBigramTypes += Object.keys(bigramCounts[prev]).length;
    }

    const vocabSize = Object.keys(unigramCounts).length;

    trained = vocabSize > 0;
    statusPill.textContent = trained ? "Trained" : "Not enough data";
    vocabPill.textContent = trained ? String(vocabSize) : "-";
    tokenPill.textContent = trained ? String(totalTokens) : "-";
    bigramPill.textContent = trained ? String(totalBigramTypes) : "-";

    resetGeneration();
    renderModelPeek();
    updateUIEnabled();
    renderOptions();
  }

  function resetGeneration() {
    generated = [];
    context = START;
    sentenceBox.textContent = "(not started)";
    contextPill.textContent = context;
  }

  function currentSentenceString() {
    if (generated.length === 0) return "";
    return generated.join(tokenizeMode.value === "char" ? "" : " ");
  }

  function getDistribution() {
    if (!trained) return [];

    const modelType = modelTypeSel.value;

    if (modelType === "unigram") {
      let total = 0;
      for (const [tok, c] of Object.entries(unigramCounts)) {
        if (tok === START) continue;
        total += c;
      }
      const arr = [];
      for (const [tok, c] of Object.entries(unigramCounts)) {
        if (tok === START) continue;
        arr.push([tok, c, total > 0 ? c / total : 0]);
      }
      arr.sort((a, b) => b[2] - a[2] || b[1] - a[1] || a[0].localeCompare(b[0]));
      return arr;
    }

    if (bigramCounts[context]) {
      const distMap = bigramCounts[context];
      const total = Object.values(distMap).reduce((s, n) => s + n, 0);
      const arr = Object.entries(distMap).map(([tok, c]) => [tok, c, total > 0 ? c / total : 0]);
      arr.sort((a, b) => b[2] - a[2] || b[1] - a[1] || a[0].localeCompare(b[0]));
      return arr;
    }

    let total = 0;
    for (const [tok, c] of Object.entries(unigramCounts)) {
      if (tok === START) continue;
      total += c;
    }
    const arr = [];
    for (const [tok, c] of Object.entries(unigramCounts)) {
      if (tok === START) continue;
      arr.push([tok, c, total > 0 ? c / total : 0]);
    }
    arr.sort((a, b) => b[2] - a[2] || b[1] - a[1] || a[0].localeCompare(b[0]));
    return arr;
  }

  function pickRandomFromDist(dist) {
    const r = Math.random();
    let acc = 0;
    for (const [tok, , p] of dist) {
      acc += p;
      if (r <= acc) return tok;
    }
    return dist.length ? dist[dist.length - 1][0] : null;
  }

  function stepChoose(tok) {
    if (!trained) return;

    const maxLen = clampInt(maxLenInput.value, 1, 500, 30);

    if (tok === END) {
      context = START;
      contextPill.textContent = context;

      const s = currentSentenceString();
      sentenceBox.textContent = s ? s + "  (← sentence ended)" : "(sentence ended: empty)";
      renderOptions();
      updateUIEnabled();
      return;
    }

    generated.push(tok);

    context = tok;
    contextPill.textContent = context;

    const s = currentSentenceString();
    sentenceBox.textContent = s || "(not started)";

    if (generated.length >= maxLen) {
      sentenceBox.textContent = s + "  (max length reached)";
    }

    renderOptions();
    updateUIEnabled();
  }

  function undo() {
    if (generated.length === 0) return;
    generated.pop();

    context = generated.length ? generated[generated.length - 1] : START;
    contextPill.textContent = context;

    const s = currentSentenceString();
    sentenceBox.textContent = s || "(not started)";

    renderOptions();
    updateUIEnabled();
  }

  function updateUIEnabled() {
    resetBtn.disabled = !trained || (generated.length === 0 && context === START);
    undoBtn.disabled = !trained || generated.length === 0;
    randomBtn.disabled = !trained;
  }

  function renderOptions() {
    optionsDiv.innerHTML = "";
    noOptions.style.display = "none";

    if (!trained) {
      contextPill.textContent = "-";
      return;
    }

    const dist = getDistribution();
    const topK = clampInt(topKInput.value, 1, 200, 30);
    const shown = dist.slice(0, topK);

    const maxLen = clampInt(maxLenInput.value, 1, 500, 30);
    const reached = generated.length >= maxLen;

    let ensureEnd = null;
    const endEntry = dist.find(([t]) => t === END);
    if (endEntry && !shown.some(([t]) => t === END)) ensureEnd = endEntry;

    const finalList = ensureEnd ? [ensureEnd, ...shown] : shown;

    if (finalList.length === 0) {
      noOptions.style.display = "block";
      return;
    }

    for (const [tok, count, prob] of finalList) {
      const opt = document.createElement("div");
      opt.className = "opt";

      const left = document.createElement("div");
      const btn = document.createElement("button");

      if (reached && tok !== END) btn.disabled = true;

      btn.textContent = tok;
      btn.title = `count=${count}, prob=${(prob * 100).toFixed(2)}%`;
      btn.addEventListener("click", () => stepChoose(tok));
      left.appendChild(btn);

      const right = document.createElement("div");
      const bar = document.createElement("div");
      bar.className = "bar";
      const fill = document.createElement("div");
      fill.style.width = `${Math.max(0, Math.min(100, prob * 100))}%`;
      bar.appendChild(fill);

      const meta = document.createElement("div");
      meta.className = "prob";
      meta.innerHTML = `<span>${(prob * 100).toFixed(1)}%</span><span>n=${count}</span>`;

      right.appendChild(bar);
      right.appendChild(meta);

      opt.appendChild(left);
      opt.appendChild(right);
      optionsDiv.appendChild(opt);
    }
  }

  function renderModelPeek() {
    if (!trained) {
      modelPeek.innerHTML = "<div class='muted'>Not trained yet.</div>";
      return;
    }

    const peekTop = 6;

    const prevCandidates = Object.entries(unigramCounts)
      .filter(([tok]) => tok !== END)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 12)
      .map(([tok]) => tok);

    const rows = [];
    for (const prev of prevCandidates) {
      if (!bigramCounts[prev]) continue;
      const nextMap = bigramCounts[prev];
      const total = Object.values(nextMap).reduce((s, n) => s + n, 0);
      const nextSorted = Object.entries(nextMap)
        .map(([t, c]) => [t, c, total > 0 ? c / total : 0])
        .sort((a, b) => b[2] - a[2])
        .slice(0, peekTop);

      const pretty = nextSorted.map(([t, c, p]) => `${t} (${(p*100).toFixed(1)}%, n=${c})`).join(" / ");
      rows.push({ prev, pretty });
    }

    if (rows.length === 0) {
      modelPeek.innerHTML = "<div class='muted'>No bigram transitions found (try more data).</div>";
      return;
    }

    const table = document.createElement("table");
    table.innerHTML = `
      <thead>
        <tr><th style="width: 130px;">prev</th><th>next (top)</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = table.querySelector("tbody");

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td><code class="k">${escapeHtml(r.prev)}</code></td><td>${escapeHtml(r.pretty)}</td>`;
      tbody.appendChild(tr);
    }

    modelPeek.innerHTML = "";
    modelPeek.appendChild(table);
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  trainBtn.addEventListener("click", () => trainFromText(trainText.value));

  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      trainText.value = text;
      trainFromText(trainText.value);
    } catch {
      alert("Failed to read the file. Please try another .txt file.");
    } finally {
      fileInput.value = "";
    }
  });

  resetBtn.addEventListener("click", () => {
    resetGeneration();
    renderOptions();
    updateUIEnabled();
  });

  undoBtn.addEventListener("click", () => undo());

  randomBtn.addEventListener("click", () => {
    const dist = getDistribution();
    if (dist.length === 0) return;
    const tok = pickRandomFromDist(dist);
    if (tok) stepChoose(tok);
  });

  modelTypeSel.addEventListener("change", renderOptions);
  topKInput.addEventListener("change", renderOptions);
  maxLenInput.addEventListener("change", renderOptions);

  tokenizeMode.addEventListener("change", () => {
    if (trained) trainFromText(trainText.value);
  });

  lowercaseChk.addEventListener("change", () => {
    if (trained) trainFromText(trainText.value);
  });

  // Auto-load + auto-train on page load
  trainText.value = DEFAULT_SAMPLE;
  trainFromText(trainText.value);

  updateUIEnabled();
  renderOptions();
})();
</script>
</body>
</html>
