<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MNIST CNN Explainer (Single-file)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; }
    body { margin: 18px; line-height: 1.35; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; align-items: start; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    .card h2 { font-size: 14px; margin: 0 0 8px; }
    button, input, select { padding: 8px 10px; border: 1px solid #ddd; border-radius: 12px; background:#fff; }
    button { cursor: pointer; }
    button:hover { background:#f7f7f7; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .controls { display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
    .small { font-size: 12px; color:#444; }
    .muted { color:#666; }
    .pill { padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; }
    .mono { font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .canvasRow { display:flex; gap: 12px; flex-wrap: wrap; align-items: start; }
    canvas { border: 1px solid #eee; border-radius: 12px; background: #000; }
    .mini { background: #fff; }
    .outbox { border:1px solid #eee; border-radius:12px; padding:10px; white-space: pre-wrap; }
    .bars { border:1px solid #eee; border-radius:12px; overflow:hidden; }
    .barRow { display:grid; grid-template-columns: 30px 1fr 70px; gap:10px; padding:8px 10px; border-top:1px solid #f1f1f1; align-items:center; }
    .barRow:first-child { border-top:none; }
    .barWrap { height: 10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar { height:100%; background:#bbb; width:0%; }
    .fmGrid { display:grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    .fmItem { border:1px solid #eee; border-radius:12px; padding:6px; cursor:pointer; user-select:none; background:#fff; }
    .fmItem:hover { background:#fafafa; }
    .fmItem canvas { width: 100%; height: auto; border-radius:10px; background:#fff; border:1px solid #f1f1f1; }
    .table { border:1px solid #eee; border-radius:12px; overflow:hidden; }
    .tRow { display:grid; grid-template-columns: 1.2fr 0.8fr 1fr 0.9fr; gap:10px; padding:8px 10px; border-top:1px solid #f1f1f1; align-items:center; }
    .tRow:first-child { border-top:none; }
    .tHead { background:#fafafa; font-weight:700; }
    .footer { margin-top: 10px; font-size: 12px; color: #666; }
    .kbd { font: 12px ui-monospace; border: 1px solid #ddd; border-bottom-width: 2px; padding: 1px 6px; border-radius: 8px; background: #fafafa; }
    .warn { color:#8a4b00; }
    .hr { height:1px; background:#eee; margin:10px 0; }

    /* Modal */
    .modalBack {
      position: fixed; inset: 0; background: rgba(0,0,0,0.35);
      display:none; align-items:center; justify-content:center; padding: 18px; z-index: 999;
    }
    .modal {
      width: min(820px, 96vw);
      background:#fff; border-radius: 14px; border:1px solid #ddd; padding: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    .modalTop { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .modalCanvasWrap { border:1px solid #eee; border-radius: 12px; padding: 10px; background:#fafafa; }
    .modal canvas { background:#fff; border:1px solid #eee; border-radius: 12px; }
    .tag { display:inline-block; padding: 2px 8px; border:1px solid #ddd; border-radius: 999px; font-size: 12px; color:#444; }
    .kernelGrid { display:grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    .kernelItem { border:1px solid #eee; border-radius:12px; padding:8px; background:#fff; }
    .kernelItem canvas { width: 100%; height: auto; background:#fff; border-radius: 10px; border:1px solid #f1f1f1; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>

<body>
  <h1>MNIST CNN Explainer: draw → tensor → conv/pool internals → prediction</h1>

  <div class="row">
    <div class="card">
      <h2>1) Model + input</h2>

      <div class="controls">
        <button id="loadModelBtn">Load pretrained CNN (CDN)</button>
        <span class="pill" id="modelPill">Model: not loaded</span>
        <span class="pill" id="ioPill">I/O: —</span>
      </div>

      <div class="controls" style="margin-top:10px;">
        <button id="clearBtn">Clear drawing</button>
        <button id="sampleBtn" disabled>Load random MNIST sample</button>
        <span class="pill" id="dataPill">MNIST sprite: not loaded</span>
      </div>

      <div class="canvasRow" style="margin-top:10px;">
        <div>
          <div class="small muted">Draw here (280×280)</div>
          <canvas id="draw" width="280" height="280"></canvas>
        </div>
        <div>
          <div class="small muted">Downsampled (28×28)</div>
          <canvas id="mini" class="mini" width="28" height="28" style="width:140px;height:140px;"></canvas>
          <div class="small muted" style="margin-top:6px;">(what the CNN sees)</div>
        </div>
      </div>

      <div class="controls" style="margin-top:10px;">
        <button id="runBtn" disabled>Run inference</button>
        <button id="stepBtn" disabled>Step selected layer</button>
        <select id="layerSelect" disabled></select>
      </div>

      <div class="outbox mono" id="logBox" style="margin-top:10px;">—</div>

      <div class="hr"></div>

      <h2>2) Layer inspector (how CNN is configured)</h2>
      <div class="small muted">This shows: kernel size, stride, padding, activation, and output shape (computed on current input).</div>
      <div class="table mono" id="layerTable" style="margin-top:8px;"></div>

      <div class="footer warn" id="modelNote">
        Note: public TFJS MNIST models vary. This demo auto-detects conv/pool layers and builds intermediate outputs dynamically.
      </div>
    </div>

    <div class="card">
      <h2>3) Output + internals</h2>

      <div class="grid2">
        <div>
          <div class="small muted">Prediction probabilities</div>
          <div class="bars" id="probBars"></div>
        </div>

        <div>
          <div class="small muted">Manual 3×3 convolution (from conv1 kernel)</div>
          <div class="outbox mono" id="convBox">Load model, then preprocess/run to enable.</div>
          <div class="controls" style="margin-top:8px;">
            <span class="small muted">filter idx:</span>
            <input id="fIdx" type="number" min="0" value="0" style="width:80px;">
            <span class="small muted">x,y:</span>
            <input id="px" type="number" min="0" max="25" value="10" style="width:70px;">
            <input id="py" type="number" min="0" max="25" value="10" style="width:70px;">
            <button id="calcConvBtn" disabled>Compute</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>4) Feature maps (click to enlarge)</h2>
      <div class="small muted">Shows first 16 channels. Click a channel for big view + min/max.</div>

      <div style="margin-top:10px;">
        <div class="small muted">From first Conv/Pool layer output</div>
        <div class="fmGrid" id="fmA"></div>
      </div>

      <div style="margin-top:12px;">
        <div class="small muted">From second Conv/Pool layer output</div>
        <div class="fmGrid" id="fmB"></div>
      </div>

      <div class="hr"></div>

      <h2>5) Kernel visualization (Conv filters)</h2>
      <div class="controls">
        <span class="small muted">conv layer:</span>
        <select id="kernelLayerSelect" disabled></select>
        <span class="small muted">filter idx:</span>
        <input id="kernelFilterIdx" type="number" min="0" value="0" style="width:90px;">
        <button id="renderKernelBtn" disabled>Render kernels</button>
        <span class="pill" id="kernelInfo">—</span>
      </div>
      <div class="small muted" style="margin-top:6px;">Heatmap uses min→black, max→white (per-kernel normalization).</div>
      <div class="kernelGrid" id="kernelGrid" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- Modal for feature map enlarge -->
  <div class="modalBack" id="modalBack">
    <div class="modal">
      <div class="modalTop">
        <div class="mono" id="modalTitle">—</div>
        <button id="modalClose">Close</button>
      </div>
      <div class="controls" style="margin-top:8px;">
        <span class="tag" id="modalShape">shape=—</span>
        <span class="tag" id="modalStats">min=— max=—</span>
      </div>
      <div class="modalCanvasWrap" style="margin-top:10px;">
        <canvas id="modalCanvas" width="256" height="256"></canvas>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const loadModelBtn = $("loadModelBtn");
    const sampleBtn = $("sampleBtn");
    const clearBtn = $("clearBtn");
    const runBtn = $("runBtn");
    const stepBtn = $("stepBtn");
    const layerSelect = $("layerSelect");

    const modelPill = $("modelPill");
    const ioPill = $("ioPill");
    const dataPill = $("dataPill");
    const logBox = $("logBox");

    const drawCanvas = $("draw");
    const miniCanvas = $("mini");

    const probBars = $("probBars");
    const layerTable = $("layerTable");

    const fmA = $("fmA");
    const fmB = $("fmB");

    const convBox = $("convBox");
    const fIdxEl = $("fIdx");
    const pxEl = $("px");
    const pyEl = $("py");
    const calcConvBtn = $("calcConvBtn");

    const kernelLayerSelect = $("kernelLayerSelect");
    const kernelFilterIdx = $("kernelFilterIdx");
    const renderKernelBtn = $("renderKernelBtn");
    const kernelGrid = $("kernelGrid");
    const kernelInfo = $("kernelInfo");

    const modalBack = $("modalBack");
    const modalClose = $("modalClose");
    const modalTitle = $("modalTitle");
    const modalShape = $("modalShape");
    const modalStats = $("modalStats");
    const modalCanvas = $("modalCanvas");

    // Pretrained TFJS MNIST CNN model
    const MODEL_URL = "https://storage.googleapis.com/tfjs-models/tfjs/mnist_transfer_cnn_v1/model.json";

    // MNIST sprite dataset (common TFJS tutorial dataset)
    const MNIST_SPRITE = "https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png";
    const MNIST_LABELS = "https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8";
    const SPRITE_COLS = 100;
    const IMAGE_SIZE = 28;

    const state = {
      model: null,
      outputClasses: 10,
      spriteImg: null,
      labels: null,

      lastInput28: null,
      lastInputTensor: null,

      // Intermediate inspection
      layerInfos: [],         // [{idx, name, className, config}]
      layerModels: new Map(), // layerIdx -> tf.model outputs that layer
      keyLayerIdxs: [],       // chosen conv/pool/logits layer indices

      lastLayerOutputs: new Map(), // layerIdx -> tf.Tensor
    };

    function setModelStatus(s) { modelPill.textContent = `Model: ${s}`; }
    function setIOStatus(s) { ioPill.textContent = `I/O: ${s}`; }
    function setLog(s) { logBox.textContent = s; }

    function disposeLastOutputs() {
      for (const t of state.lastLayerOutputs.values()) t?.dispose?.();
      state.lastLayerOutputs.clear();
    }

    function clearTF() {
      disposeLastOutputs();
      if (state.lastInputTensor) { state.lastInputTensor.dispose(); state.lastInputTensor = null; }
    }

    // ---------- Bars ----------
    function initBars(k) {
      probBars.innerHTML = "";
      for (let i = 0; i < k; i++) {
        const row = document.createElement("div");
        row.className = "barRow mono";
        row.innerHTML = `
          <div>${i}</div>
          <div class="barWrap"><div class="bar" id="bar${i}"></div></div>
          <div id="pct${i}" style="text-align:right;">0.0%</div>
        `;
        probBars.appendChild(row);
      }
    }

    function updateBars(probs) {
      const max = Math.max(...probs, 1e-9);
      for (let i = 0; i < probs.length; i++) {
        const p = probs[i];
        const w = Math.max(1, Math.round((p / max) * 100));
        const bar = document.getElementById(`bar${i}`);
        const pct = document.getElementById(`pct${i}`);
        if (bar) bar.style.width = `${w}%`;
        if (pct) pct.textContent = `${(p * 100).toFixed(1)}%`;
      }
    }

    // ---------- Drawing ----------
    const ctx = drawCanvas.getContext("2d");
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

    let drawing = false;
    let last = null;

    function drawLine(x0, y0, x1, y1) {
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 18;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();
    }

    function getPos(ev) {
      const r = drawCanvas.getBoundingClientRect();
      const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - r.left;
      const y = (ev.touches ? ev.touches[0].clientY : ev.clientY) - r.top;
      return { x, y };
    }

    function start(ev) { drawing = true; last = getPos(ev); ev.preventDefault(); }
    function move(ev) {
      if (!drawing) return;
      const p = getPos(ev);
      drawLine(last.x, last.y, p.x, p.y);
      last = p;
      ev.preventDefault();
      preprocessTo28();
    }
    function end(ev) { drawing = false; last = null; ev.preventDefault(); preprocessTo28(); }

    drawCanvas.addEventListener("mousedown", start);
    drawCanvas.addEventListener("mousemove", move);
    window.addEventListener("mouseup", end);

    drawCanvas.addEventListener("touchstart", start, { passive:false });
    drawCanvas.addEventListener("touchmove", move, { passive:false });
    window.addEventListener("touchend", end, { passive:false });

    clearBtn.onclick = () => {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
      preprocessTo28();
      setLog("Cleared.");
    };

    // ---------- Preprocess ----------
    function preprocessTo28() {
      const mctx = miniCanvas.getContext("2d");
      mctx.imageSmoothingEnabled = true;
      mctx.clearRect(0,0,28,28);
      mctx.drawImage(drawCanvas, 0, 0, 28, 28);

      const img = mctx.getImageData(0,0,28,28);
      const data = img.data;

      const arr = new Float32Array(28*28);
      for (let i = 0; i < 28*28; i++) {
        const r = data[i*4+0];
        const g = data[i*4+1];
        const b = data[i*4+2];
        const gray = (r + g + b) / (3 * 255);
        arr[i] = gray;
      }

      state.lastInput28 = arr;
      clearTF();
      state.lastInputTensor = tf.tensor4d(arr, [1, 28, 28, 1]);

      if (state.model) calcConvBtn.disabled = false;
    }

    // ---------- MNIST sprite loader ----------
    async function loadMnistSprite() {
      dataPill.textContent = "MNIST sprite: loading…";

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = MNIST_SPRITE;

      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Failed to load MNIST sprite"));
      });

      const labRes = await fetch(MNIST_LABELS);
      const labBuf = await labRes.arrayBuffer();
      const labels = new Uint8Array(labBuf);

      state.spriteImg = img;
      state.labels = labels;

      dataPill.textContent = `MNIST sprite: loaded (${labels.length} labels)`;
      sampleBtn.disabled = false;
    }

    function drawSample(index) {
      const img = state.spriteImg;
      const labels = state.labels;
      if (!img || !labels) return;

      const cols = SPRITE_COLS;
      const sx = (index % cols) * IMAGE_SIZE;
      const sy = Math.floor(index / cols) * IMAGE_SIZE;

      const off = document.createElement("canvas");
      off.width = 28; off.height = 28;
      const octx = off.getContext("2d");
      octx.drawImage(img, sx, sy, 28, 28, 0, 0, 28, 28);

      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,280,280);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(off, 0, 0, 280, 280);

      preprocessTo28();
      setLog(`Loaded sample index=${index}, label=${labels[index] ?? "?"}`);
    }

    sampleBtn.onclick = () => {
      const n = state.labels?.length ?? 0;
      if (n === 0) return;
      const idx = Math.floor(Math.random() * n);
      drawSample(idx);
    };

    // ---------- Layer inspector helpers ----------
    function safeGetConfig(layer) {
      try { return layer.getConfig ? layer.getConfig() : {}; } catch { return {}; }
    }

    function fmtShape(shape) {
      if (!shape) return "—";
      return JSON.stringify(shape);
    }

    function layerSummary(layer) {
      const cls = layer.getClassName?.() || layer.className || "Layer";
      const cfg = safeGetConfig(layer);

      const parts = [];
      if (cfg.kernelSize) parts.push(`k=${Array.isArray(cfg.kernelSize)?cfg.kernelSize.join("x"):cfg.kernelSize}`);
      if (cfg.strides) parts.push(`s=${Array.isArray(cfg.strides)?cfg.strides.join("x"):cfg.strides}`);
      if (cfg.padding) parts.push(`pad=${cfg.padding}`);
      if (cfg.activation) parts.push(`act=${cfg.activation}`);
      if (cfg.poolSize) parts.push(`pool=${Array.isArray(cfg.poolSize)?cfg.poolSize.join("x"):cfg.poolSize}`);
      if (cfg.filters) parts.push(`filters=${cfg.filters}`);

      return { cls, cfg, desc: parts.join(" ") || "—" };
    }

    function isConv(layer) { return (layer.getClassName?.() === "Conv2D"); }
    function isPool(layer) {
      const c = layer.getClassName?.();
      return c === "MaxPooling2D" || c === "AveragePooling2D";
    }

    function pickKeyLayers(model) {
      const convIdxs = [];
      const poolIdxs = [];
      for (let i = 0; i < model.layers.length; i++) {
        const l = model.layers[i];
        if (isConv(l)) convIdxs.push(i);
        if (isPool(l)) poolIdxs.push(i);
      }
      // choose: conv1, pool1, conv2, pool2, logits (= last layer)
      const keys = [];
      if (convIdxs[0] != null) keys.push(convIdxs[0]);
      if (poolIdxs[0] != null) keys.push(poolIdxs[0]);
      if (convIdxs[1] != null) keys.push(convIdxs[1]);
      if (poolIdxs[1] != null) keys.push(poolIdxs[1]);
      keys.push(model.layers.length - 1);
      // unique
      return Array.from(new Set(keys));
    }

    function buildLayerModels() {
      state.layerModels.clear();
      for (let i = 0; i < state.model.layers.length; i++) {
        const layer = state.model.layers[i];
        // Some layers may not be usable as model outputs (rare), but usually are.
        try {
          const m = tf.model({ inputs: state.model.inputs, outputs: layer.output });
          state.layerModels.set(i, m);
        } catch {
          // ignore
        }
      }
    }

    function renderLayerSelect() {
      layerSelect.innerHTML = "";
      for (let i = 0; i < state.model.layers.length; i++) {
        const l = state.model.layers[i];
        const { cls, desc } = layerSummary(l);
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = `${i}: ${l.name || cls}  (${cls})  ${desc}`;
        layerSelect.appendChild(opt);
      }
      // default: first conv or layer 0
      const firstConv = state.model.layers.findIndex(isConv);
      layerSelect.value = String(firstConv >= 0 ? firstConv : 0);
    }

    function renderLayerTable(outputShapesByIdx) {
      layerTable.innerHTML = "";
      const head = document.createElement("div");
      head.className = "tRow tHead";
      head.innerHTML = `<div>Layer</div><div>Type</div><div>Config (k/s/pad/act/pool)</div><div>Output shape</div>`;
      layerTable.appendChild(head);

      for (let i = 0; i < state.model.layers.length; i++) {
        const l = state.model.layers[i];
        const { cls, desc } = layerSummary(l);

        const row = document.createElement("div");
        row.className = "tRow";
        const name = l.name ? l.name : `layer_${i}`;
        row.innerHTML = `
          <div>${i}: ${name}</div>
          <div>${cls}</div>
          <div>${desc}</div>
          <div>${outputShapesByIdx.get(i) || "—"}</div>
        `;
        layerTable.appendChild(row);
      }
    }

    // ---------- Feature map rendering ----------
    function clearFM(container) { container.innerHTML = ""; }

    function tensorToChannelCanvas2D(data2d, scale = 10) {
      // data2d: h x w numbers
      const h = data2d.length;
      const w = data2d[0].length;

      let min = Infinity, max = -Infinity;
      for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
        const v = data2d[y][x];
        if (v < min) min = v;
        if (v > max) max = v;
      }
      const denom = (max - min) || 1e-6;

      const cv = document.createElement("canvas");
      cv.width = w;
      cv.height = h;

      const cctx = cv.getContext("2d");
      const img = cctx.createImageData(w, h);
      for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
        const v = (data2d[y][x] - min) / denom;
        const g = Math.max(0, Math.min(255, Math.round(v * 255)));
        const i = (y*w + x) * 4;
        img.data[i+0] = g;
        img.data[i+1] = g;
        img.data[i+2] = g;
        img.data[i+3] = 255;
      }
      cctx.putImageData(img, 0, 0);

      return { cv, min, max, h, w };
    }

    function openModal({ title, shapeText, min, max, data2d }) {
      modalTitle.textContent = title;
      modalShape.textContent = `shape=${shapeText}`;
      modalStats.textContent = `min=${min.toFixed(4)} max=${max.toFixed(4)}`;

      // Draw scaled to modal canvas (nearest-neighbor)
      const h = data2d.length;
      const w = data2d[0].length;

      const { cv } = tensorToChannelCanvas2D(data2d);

      const mctx = modalCanvas.getContext("2d");
      mctx.imageSmoothingEnabled = false;
      mctx.clearRect(0,0,modalCanvas.width, modalCanvas.height);

      const scale = Math.floor(Math.min(modalCanvas.width / w, modalCanvas.height / h));
      const dw = w * scale;
      const dh = h * scale;

      const ox = Math.floor((modalCanvas.width - dw)/2);
      const oy = Math.floor((modalCanvas.height - dh)/2);

      mctx.drawImage(cv, 0, 0, w, h, ox, oy, dw, dh);

      modalBack.style.display = "flex";
    }

    modalClose.onclick = () => { modalBack.style.display = "none"; };
    modalBack.onclick = (e) => { if (e.target === modalBack) modalBack.style.display = "none"; };

    function renderFeatureMaps(container, actTensor, labelPrefix, maxChannels = 16) {
      clearFM(container);
      if (!actTensor) return;

      const shape = actTensor.shape; // [1,h,w,c] or [1,h,w] etc.
      if (shape.length !== 4) {
        const div = document.createElement("div");
        div.className = "outbox mono";
        div.textContent = `Unexpected activation shape: ${JSON.stringify(shape)}`;
        container.appendChild(div);
        return;
      }

      const [_, h, w, c] = shape;
      const channels = Math.min(c, maxChannels);

      const act = actTensor.squeeze([0]); // [h,w,c]
      const data = act.arraySync();       // h x w x c

      for (let ch = 0; ch < channels; ch++) {
        const item = document.createElement("div");
        item.className = "fmItem";

        const label = document.createElement("div");
        label.className = "small muted mono";
        label.textContent = `${labelPrefix} ch${ch} (${h}×${w})`;
        label.style.marginBottom = "6px";

        // Build 2d data for channel
        const d2 = new Array(h);
        for (let y = 0; y < h; y++) {
          const row = new Array(w);
          for (let x = 0; x < w; x++) row[x] = data[y][x][ch];
          d2[y] = row;
        }

        const { cv, min, max } = tensorToChannelCanvas2D(d2);

        item.appendChild(label);
        item.appendChild(cv);

        item.onclick = () => {
          openModal({
            title: `${labelPrefix} channel ${ch}`,
            shapeText: `[${h},${w}]`,
            min,
            max,
            data2d: d2
          });
        };

        container.appendChild(item);
      }

      act.dispose();
    }

    // ---------- Kernel visualization ----------
    function clearKernels() { kernelGrid.innerHTML = ""; kernelInfo.textContent = "—"; }

    function renderKernelHeatmap(kernel2d) {
      // kernel2d: kh x kw
      const kh = kernel2d.length;
      const kw = kernel2d[0].length;

      let min = Infinity, max = -Infinity;
      for (let y = 0; y < kh; y++) for (let x = 0; x < kw; x++) {
        const v = kernel2d[y][x];
        if (v < min) min = v;
        if (v > max) max = v;
      }
      const denom = (max - min) || 1e-6;

      const cv = document.createElement("canvas");
      cv.width = kw;
      cv.height = kh;

      const cctx = cv.getContext("2d");
      const img = cctx.createImageData(kw, kh);

      for (let y = 0; y < kh; y++) for (let x = 0; x < kw; x++) {
        const v = (kernel2d[y][x] - min) / denom;
        const g = Math.max(0, Math.min(255, Math.round(v * 255)));
        const i = (y*kw + x) * 4;
        img.data[i+0] = g;
        img.data[i+1] = g;
        img.data[i+2] = g;
        img.data[i+3] = 255;
      }
      cctx.putImageData(img, 0, 0);

      return { cv, min, max };
    }

    function renderSelectedKernel() {
      clearKernels();
      if (!state.model) return;

      const layerIdx = parseInt(kernelLayerSelect.value, 10);
      const layer = state.model.layers[layerIdx];
      if (!layer || !isConv(layer)) {
        kernelInfo.textContent = "Selected layer is not Conv2D.";
        return;
      }

      const ws = layer.getWeights();
      if (!ws || ws.length === 0) {
        kernelInfo.textContent = "No weights found.";
        return;
      }

      const kernel = ws[0]; // [kh,kw,inC,outC]
      const [kh, kw, inC, outC] = kernel.shape;

      let fi = parseInt(kernelFilterIdx.value || "0", 10);
      fi = Math.max(0, Math.min(outC - 1, fi));
      kernelFilterIdx.value = String(fi);

      const K = kernel.arraySync(); // kh x kw x inC x outC

      kernelInfo.textContent = `kernel shape=[${kh},${kw},${inC},${outC}]  filter=${fi}`;

      for (let ic = 0; ic < inC; ic++) {
        const item = document.createElement("div");
        item.className = "kernelItem";

        const title = document.createElement("div");
        title.className = "small muted mono";
        title.textContent = `inC ${ic} → outC ${fi}`;
        title.style.marginBottom = "6px";

        const k2 = new Array(kh);
        for (let y = 0; y < kh; y++) {
          const row = new Array(kw);
          for (let x = 0; x < kw; x++) row[x] = K[y][x][ic][fi];
          k2[y] = row;
        }

        const { cv, min, max } = renderKernelHeatmap(k2);

        const stats = document.createElement("div");
        stats.className = "small muted mono";
        stats.textContent = `min=${min.toFixed(4)} max=${max.toFixed(4)}`;

        item.appendChild(title);
        item.appendChild(cv);
        item.appendChild(stats);
        kernelGrid.appendChild(item);
      }
    }

    // ---------- Manual conv (3×3) ----------
    function getFirstConvLayer() {
      if (!state.model) return null;
      const idx = state.model.layers.findIndex(isConv);
      return idx >= 0 ? { idx, layer: state.model.layers[idx] } : null;
    }

    function computeManualConv() {
      if (!state.lastInput28) { convBox.textContent = "Run preprocess first."; return; }
      const first = getFirstConvLayer();
      if (!first) { convBox.textContent = "No Conv2D layer found."; return; }

      const layer = first.layer;
      const ws = layer.getWeights();
      if (!ws || ws.length === 0) { convBox.textContent = "No conv weights found."; return; }

      const kernel = ws[0]; // [kh,kw,inC,outC]
      const [kh, kw, inC, outC] = kernel.shape;

      if (kh !== 3 || kw !== 3 || inC !== 1) {
        convBox.textContent =
          `Manual conv is implemented for a 3×3 kernel with 1 input channel.\n` +
          `This model's first conv kernel shape is [${kh},${kw},${inC},${outC}].`;
        return;
      }

      const fi = Math.max(0, Math.min(outC - 1, parseInt(fIdxEl.value || "0", 10)));
      const px = Math.max(0, Math.min(28 - kw, parseInt(pxEl.value || "0", 10)));
      const py = Math.max(0, Math.min(28 - kh, parseInt(pyEl.value || "0", 10)));

      fIdxEl.value = String(fi);
      pxEl.value = String(px);
      pyEl.value = String(py);

      const K = kernel.arraySync(); // 3 x 3 x 1 x outC
      let sum = 0;
      const lines = [];
      lines.push(`Manual 3×3 conv (first Conv2D), one output channel`);
      lines.push(`kernel shape=[${kh},${kw},${inC},${outC}]  filter=${fi}  position=(x=${px},y=${py})`);
      lines.push("");

      for (let y = 0; y < 3; y++) {
        const row = [];
        for (let x = 0; x < 3; x++) {
          const w = K[y][x][0][fi];
          const v = state.lastInput28[(py + y) * 28 + (px + x)];
          sum += w * v;
          row.push(`${w.toFixed(3)}*${v.toFixed(3)}`);
        }
        lines.push(row.join("  "));
      }
      lines.push("");
      lines.push(`dot sum = ${sum.toFixed(4)}  (bias + activation not included)`);

      convBox.textContent = lines.join("\n");
    }

    calcConvBtn.onclick = computeManualConv;

    // ---------- Inference + step ----------
    async function runLayerOutput(layerIdx) {
      if (!state.model || !state.lastInputTensor) return null;
      const m = state.layerModels.get(layerIdx);
      if (!m) return null;

      // Dispose previous output for that layer
      const prev = state.lastLayerOutputs.get(layerIdx);
      if (prev) prev.dispose();

      const out = m.predict(state.lastInputTensor);
      state.lastLayerOutputs.set(layerIdx, out);
      return out;
    }

    async function computeAllKeyOutputs() {
      disposeLastOutputs();
      const outShapes = new Map();

      for (const idx of state.keyLayerIdxs) {
        const t = await runLayerOutput(idx);
        if (t) outShapes.set(idx, fmtShape(t.shape));
      }
      return outShapes;
    }

    function bestIndex(probs) {
      let bi = 0;
      for (let i = 1; i < probs.length; i++) if (probs[i] > probs[bi]) bi = i;
      return bi;
    }

    async function runInference() {
      if (!state.model || !state.lastInputTensor) return;

      setLog("Running inference…");
      await tf.nextFrame();

      // Final output
      const logits = state.model.predict(state.lastInputTensor);
      const probsT = tf.softmax(logits);
      const probs = Array.from(await probsT.data());
      const bi = bestIndex(probs);

      updateBars(probs);

      // Compute and show key outputs + shapes
      const shapes = await computeAllKeyOutputs();
      // Also compute shapes for all layers shown in the table (by stepping each layer would be slow),
      // so we only fill output shapes for layers we computed; others show "—".
      renderLayerTable(shapes);

      // Render feature maps from first two "key layers" that are 4D
      const keyTensors = state.keyLayerIdxs
        .map(i => ({ i, t: state.lastLayerOutputs.get(i) }))
        .filter(x => x.t && x.t.shape && x.t.shape.length === 4);

      const A = keyTensors[0]?.t || null;
      const B = keyTensors[1]?.t || null;

      if (A) renderFeatureMaps(fmA, A, `L${keyTensors[0].i}`, 16); else fmA.innerHTML = "";
      if (B) renderFeatureMaps(fmB, B, `L${keyTensors[1].i}`, 16); else fmB.innerHTML = "";

      setLog(
        `Prediction: ${bi}\n` +
        `Output classes: ${state.outputClasses}\n` +
        `probs: [${probs.map(x => x.toFixed(3)).join(", ")}]\n\n` +
        `Tip: Use "Step selected layer" to inspect any intermediate layer output and see its shape.`
      );

      tf.dispose([logits, probsT]);
    }

    async function stepSelectedLayer() {
      if (!state.model) return;
      if (!state.lastInputTensor) preprocessTo28();

      const idx = parseInt(layerSelect.value, 10);
      const layer = state.model.layers[idx];
      const { cls, desc } = layerSummary(layer);

      setLog(`Stepping layer ${idx} (${cls})…`);
      await tf.nextFrame();

      const out = await runLayerOutput(idx);
      if (!out) {
        setLog(`Cannot compute output for layer ${idx}.`);
        return;
      }

      const shapeStr = fmtShape(out.shape);
      setLog(`Layer ${idx}: ${layer.name || "—"} (${cls})\nconfig: ${desc}\noutput shape: ${shapeStr}\n\nIf this is 4D [1,h,w,c], you can visualize it as feature maps by picking conv/pool outputs.`);

      // If 4D, show as fmA immediately
      if (out.shape.length === 4) {
        renderFeatureMaps(fmA, out, `L${idx}`, 16);
      }
    }

    runBtn.onclick = runInference;
    stepBtn.onclick = stepSelectedLayer;

    // ---------- Model loading ----------
    async function loadModel() {
      setModelStatus("loading…");
      setIOStatus("—");
      loadModelBtn.disabled = true;

      try {
        const model = await tf.loadLayersModel(MODEL_URL);
        state.model = model;

        const inShape = model.inputs[0].shape;
        const outShape = model.outputs[0].shape;
        const outDim = outShape[outShape.length - 1];
        state.outputClasses = outDim;

        setModelStatus("loaded");
        setIOStatus(`${JSON.stringify(inShape)} → ${JSON.stringify(outShape)}`);

        initBars(state.outputClasses);

        // Build layer infos and intermediate models
        state.layerInfos = model.layers.map((l, idx) => {
          const { cls, cfg, desc } = layerSummary(l);
          return { idx, name: l.name || `layer_${idx}`, className: cls, config: cfg, desc };
        });

        buildLayerModels();

        // Key pipeline layers
        state.keyLayerIdxs = pickKeyLayers(model);

        // Populate layer selector
        renderLayerSelect();
        layerSelect.disabled = false;
        stepBtn.disabled = false;

        // Kernel controls: list Conv2D layers
        kernelLayerSelect.innerHTML = "";
        const convIdxs = model.layers.map((l,i) => ({l,i})).filter(x => isConv(x.l)).map(x => x.i);
        for (const idx of convIdxs) {
          const l = model.layers[idx];
          const opt = document.createElement("option");
          opt.value = String(idx);
          opt.textContent = `${idx}: ${l.name || "Conv2D"}`;
          kernelLayerSelect.appendChild(opt);
        }
        kernelLayerSelect.disabled = convIdxs.length === 0;
        renderKernelBtn.disabled = convIdxs.length === 0;

        renderKernelBtn.onclick = renderSelectedKernel;
        kernelLayerSelect.onchange = () => { clearKernels(); };
        kernelFilterIdx.oninput = () => { /* keep */ };

        // Enable UI
        runBtn.disabled = false;
        sampleBtn.disabled = false;
        calcConvBtn.disabled = false;

        preprocessTo28();

        // Load MNIST sprite
        loadMnistSprite().catch(() => {
          dataPill.textContent = "MNIST sprite: failed to load";
        });

        setLog(
          `Model loaded.\n` +
          `Output classes=${state.outputClasses}.\n` +
          `Draw a digit and click "Run inference".\n` +
          `Then use: Layer inspector / Step selected layer / Feature map modal / Kernel heatmaps.`
        );

        // Initial layer table with only key shapes (computed after first inference)
        renderLayerTable(new Map());

      } catch (e) {
        console.error(e);
        setModelStatus("failed (see console)");
        setIOStatus("—");
        loadModelBtn.disabled = false;
        setLog("Failed to load model. Check console.");
      }
    }

    loadModelBtn.onclick = loadModel;

    // ---------- Sample + init ----------
    function initLayerSelectPlaceholder() {
      layerSelect.innerHTML = "";
      const opt = document.createElement("option");
      opt.textContent = "Load model first";
      opt.value = "0";
      layerSelect.appendChild(opt);
    }
    initLayerSelectPlaceholder();

    // ---------- clear all ----------
    function clearAllInternals() {
      clearFM(fmA);
      clearFM(fmB);
      clearKernels();
      renderLayerTable(new Map());
      setLog("Cleared internals.");
    }

    // Clear only drawing does not clear model, but resets input tensors
    clearBtn.addEventListener("click", () => {
      clearAllInternals();
    });

    // init
    preprocessTo28();
    initBars(10);
    setModelStatus("not loaded");
    setIOStatus("—");
    setLog("Draw a digit, then load the model.");
  </script>
</body>
</html>
