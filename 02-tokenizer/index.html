<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tokenizer Demo: Step-by-step BPE Learning (Single-file)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; }
    body { margin: 18px; line-height: 1.35; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; align-items: start; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    .card h2 { font-size: 14px; margin: 0 0 8px; }
    textarea { width: 100%; height: 170px; resize: vertical; font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    input[type="text"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 12px; }
    button, select, input[type="file"] {
      padding: 8px 10px; border: 1px solid #ddd; border-radius: 12px; background: #fff;
    }
    button { cursor: pointer; }
    button:hover { background: #f7f7f7; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .small { font-size: 12px; color: #444; }
    .muted { color: #666; }
    .mono { font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .pill { padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; }
    .outbox { border: 1px solid #ddd; border-radius: 12px; padding: 10px; white-space: pre-wrap; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .list { border: 1px solid #eee; border-radius: 12px; overflow: hidden; }
    .rowItem {
      display: grid; grid-template-columns: 1fr 70px;
      gap: 10px; padding: 10px; border-top: 1px solid #f1f1f1;
      font-variant-numeric: tabular-nums;
    }
    .rowItem:first-child { border-top: none; }
    .barWrap { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; background: #bbb; width: 0%; }
    .tokenSpan {
      display: inline-block; padding: 2px 6px; margin: 2px 4px 2px 0;
      border: 1px solid #e6e6e6; border-radius: 10px; background: #fafafa;
      font: 12px ui-monospace;
    }
    .tokenSpan.hl { background: #fff2a8; border-color: #f0d36b; }
    .tokenSpan.merge { background: #c7f5c7; border-color: #7ad37a; }
    .sectionTitle { font-size: 12px; color: #666; margin: 8px 0 6px; }
    .footer { margin-top: 10px; font-size: 12px; color: #666; }
    .kbd { font: 12px ui-monospace; border: 1px solid #ddd; border-bottom-width: 2px; padding: 1px 6px; border-radius: 8px; background: #fafafa; }
  </style>
</head>
<body>
  <h1>Tokenizer Demo: Step-by-step BPE Learning (single-file index.html)</h1>

  <div class="row">
    <!-- LEFT: Training + Steps -->
    <div class="card">
      <h2>1) Training corpus</h2>
      <textarea id="corpus"></textarea>

      <div class="controls" style="margin-top:10px;">
        <button id="initBtn">Initialize</button>
        <button id="stepBtn" disabled>1 step (merge best pair)</button>
        <button id="autoBtn" disabled>Auto-run</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="resetBtn">Reset sample</button>
        <span class="pill" id="status">Not initialized</span>
      </div>

      <div class="controls" style="margin-top:10px;">
        <span class="small muted">Max steps:</span>
        <select id="maxSteps">
          <option value="10">10</option>
          <option value="25" selected>25</option>
          <option value="50">50</option>
          <option value="100">100</option>
          <option value="1000">1000</option>
        </select>

        <span class="small muted">Min pair count:</span>
        <select id="minCount">
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="5">5</option>
          <option value="10">10</option>
        </select>

        <span class="small muted">Tokenize by:</span>
        <select id="mode">
          <option value="word" selected>word (typical BPE tutorial)</option>
          <option value="char">raw characters (educational)</option>
        </select>
      </div>

      <div class="card" style="border:1px solid #eee; margin-top:10px;">
        <h2 style="margin-bottom:6px;">Load a .txt file (optional)</h2>
        <div class="controls">
          <input id="fileInput" type="file" accept=".txt,text/plain" />
          <button id="replaceFileBtn" disabled>Replace corpus</button>
        </div>
        <div class="small muted" style="margin-top:6px;">
          For huge text, the UI may slow down. Keep it small for step-by-step demos.
        </div>
      </div>

      <div class="sectionTitle">What happened in the last step?</div>
      <div class="outbox mono" id="explainBox">Initialize to start.</div>

      <div class="sectionTitle">Top pair counts (current)</div>
      <div class="list" id="pairsList"></div>

      <div class="footer">
        This demo implements a simple BPE-style merge loop:
        start from characters (plus end-of-word marker) → repeatedly merge the most frequent adjacent pair.
        Real production tokenizers add many details, but this captures the core concept.
      </div>
    </div>

    <!-- RIGHT: Tokenization visualization -->
    <div class="card">
      <h2>2) Tokenization (visualize tokens)</h2>

      <div class="controls">
        <span class="small muted">Text to tokenize:</span>
      </div>
      <input id="query" type="text" placeholder="Type text here (e.g., 'teaching tokenization is fun')" />

      <div class="controls" style="margin-top:10px;">
        <button id="tokenizeBtn" disabled>Tokenize</button>
        <span class="pill" id="vocabPill">vocab=—</span>
        <span class="pill" id="mergePill">merges=—</span>
      </div>

      <div class="sectionTitle">Tokens (current tokenizer)</div>
      <div class="outbox" id="tokensBox">—</div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <div class="sectionTitle">Current merge rules (latest first)</div>
          <div class="outbox mono" id="mergesBox" style="max-height:220px; overflow:auto;">—</div>
        </div>
        <div>
          <div class="sectionTitle">Vocabulary snapshot (sample)</div>
          <div class="outbox mono" id="vocabBox" style="max-height:220px; overflow:auto;">—</div>
        </div>
      </div>

      <div class="footer">
        Tip for teaching:
        start with a tiny corpus so students can see merges like <span class="kbd">t + h → th</span>,
        then show how longer tokens emerge (e.g., <span class="kbd">teach + ing → teaching</span>).
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const corpusEl = $("corpus");
    const initBtn = $("initBtn");
    const stepBtn = $("stepBtn");
    const autoBtn = $("autoBtn");
    const stopBtn = $("stopBtn");
    const resetBtn = $("resetBtn");
    const statusEl = $("status");

    const maxStepsEl = $("maxSteps");
    const minCountEl = $("minCount");
    const modeEl = $("mode");

    const explainBox = $("explainBox");
    const pairsList = $("pairsList");

    const queryEl = $("query");
    const tokenizeBtn = $("tokenizeBtn");
    const tokensBox = $("tokensBox");
    const mergesBox = $("mergesBox");
    const vocabBox = $("vocabBox");
    const vocabPill = $("vocabPill");
    const mergePill = $("mergePill");

    const fileInput = $("fileInput");
    const replaceFileBtn = $("replaceFileBtn");

    let state = null;
    let timer = null;

    function defaultCorpus() {
      return [
        "teaching tokenization is fun",
        "tokenization helps language models",
        "tokens can be words or subwords",
        "subword tokenizers balance vocabulary and flexibility",
        "we learn merges from data",
        "we merge frequent pairs"
      ].join("\n");
    }

    function normalizeText(s) {
      return s.replace(/\r\n/g, "\n").replace(/[“”]/g, '"').replace(/[’]/g, "'").trim();
    }

    function splitWords(line) {
      return line.trim().split(/\s+/g).filter(Boolean);
    }

    function toInitialWordSymbols(word) {
      // Classic BPE tutorials often use end-of-word marker to avoid merging across word boundaries
      // e.g., "low" -> ["l","o","w","</w>"]
      const chars = Array.from(word);
      return [...chars, "</w>"];
    }

    function buildTrainingWords(corpusText, mode) {
      const lines = normalizeText(corpusText).split("\n").map(x => x.trim()).filter(Boolean);
      const wordFreq = new Map();

      for (const line of lines) {
        if (mode === "char") {
          // treat entire line as one "word" of characters (including spaces removed)
          const w = line.replace(/\s+/g, " ");
          wordFreq.set(w, (wordFreq.get(w) || 0) + 1);
        } else {
          const words = splitWords(line.toLowerCase());
          for (const w of words) wordFreq.set(w, (wordFreq.get(w) || 0) + 1);
        }
      }

      // words: [{symbols: [...], freq}]
      const words = [];
      for (const [w, f] of wordFreq.entries()) {
        const symbols = (mode === "char")
          ? [...Array.from(w), "</w>"]
          : toInitialWordSymbols(w);
        words.push({ w, symbols, freq: f });
      }

      return words;
    }

    function pairKey(a, b) { return a + "\t" + b; }

    function countPairs(words) {
      const counts = new Map();
      for (const item of words) {
        const syms = item.symbols;
        for (let i = 0; i < syms.length - 1; i++) {
          const k = pairKey(syms[i], syms[i + 1]);
          counts.set(k, (counts.get(k) || 0) + item.freq);
        }
      }
      return counts;
    }

    function topPairs(counts, limit = 12) {
      const arr = Array.from(counts.entries()).map(([k, c]) => ({ k, c }));
      arr.sort((a, b) => b.c - a.c);
      return arr.slice(0, limit);
    }

    function mergePairInSymbols(symbols, a, b, merged) {
      // Replace occurrences of [a,b] with [merged] in a single word symbol array
      const out = [];
      for (let i = 0; i < symbols.length; i++) {
        if (i < symbols.length - 1 && symbols[i] === a && symbols[i + 1] === b) {
          out.push(merged);
          i++;
        } else {
          out.push(symbols[i]);
        }
      }
      return out;
    }

    function stepOnce() {
      if (!state) return;

      const minCount = Number(minCountEl.value);
      const counts = countPairs(state.words);
      const top = topPairs(counts, 1)[0];

      if (!top || top.c < minCount) {
        explainBox.textContent = `Stopped: no adjacent pair has count ≥ ${minCount}.`;
        stopAuto();
        render();
        return;
      }

      const [a, b] = top.k.split("\t");
      const merged = a + b; // classic BPE creates a new symbol by concatenation

      // apply merge to all words
      let changedWords = 0;
      const newWords = state.words.map(item => {
        const before = item.symbols;
        const after = mergePairInSymbols(before, a, b, merged);
        if (after.length !== before.length) changedWords++;
        return { ...item, symbols: after };
      });

      state.words = newWords;
      state.merges.unshift({ a, b, merged, count: top.c });
      state.steps++;

      explainBox.innerHTML =
        `Step <b>${state.steps}</b>: merged the most frequent pair <span class="kbd">${escapeHtml(a)} + ${escapeHtml(b)}</span> → <span class="kbd">${escapeHtml(merged)}</span> (count=${top.c}).<br/>` +
        `This creates a new token candidate and reduces the number of symbols in words where it appears (changed words: ${changedWords}).`;

      render();

      const maxSteps = Number(maxStepsEl.value);
      if (state.steps >= maxSteps) {
        explainBox.innerHTML += `<br/><b>Reached max steps (${maxSteps}).</b>`;
        stopAuto();
      }
    }

    function escapeHtml(s) {
      return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function renderPairs() {
      pairsList.innerHTML = "";
      if (!state) {
        pairsList.innerHTML = `<div class="rowItem mono">—</div>`;
        return;
      }

      const counts = countPairs(state.words);
      const top = topPairs(counts, 12);
      if (top.length === 0) {
        pairsList.innerHTML = `<div class="rowItem mono">No pairs.</div>`;
        return;
      }

      const maxC = top[0].c || 1;

      for (const item of top) {
        const [a, b] = item.k.split("\t");
        const row = document.createElement("div");
        row.className = "rowItem mono";

        const left = document.createElement("div");
        left.innerHTML =
          `<div><b>${escapeHtml(a)}</b> + <b>${escapeHtml(b)}</b></div>` +
          `<div class="barWrap" style="margin-top:6px;"><div class="bar" style="width:${Math.max(1, Math.round((item.c / maxC) * 100))}%"></div></div>`;

        const right = document.createElement("div");
        right.style.textAlign = "right";
        right.textContent = item.c;

        row.appendChild(left);
        row.appendChild(right);
        pairsList.appendChild(row);
      }
    }

    function getVocabularySnapshot(limit = 80) {
      // Build a set of symbols currently present
      const set = new Set();
      for (const item of state.words) for (const s of item.symbols) set.add(s);
      const arr = Array.from(set.values());
      arr.sort((a, b) => a.length - b.length || a.localeCompare(b));
      return arr.slice(0, limit);
    }

    function renderMerges() {
      if (!state) {
        mergesBox.textContent = "—";
        return;
      }
      const lines = state.merges.slice(0, 40).map((m, i) =>
        `${String(i + 1).padStart(2, " ")}. ${m.a} + ${m.b} -> ${m.merged}   (count=${m.count})`
      );
      mergesBox.textContent = lines.length ? lines.join("\n") : "(no merges yet)";
    }

    function renderVocab() {
      if (!state) {
        vocabBox.textContent = "—";
        return;
      }
      const v = getVocabularySnapshot(120);
      vocabBox.textContent = v.join("\n");
    }

    function tokenizeWithCurrentMerges(text) {
      // Apply merges greedily by repeatedly merging the best-ranked pair according to learned merge order.
      // For teaching: we use merge order = state.merges (latest first) but for tokenization, typical BPE uses learned order (earlier merges higher priority).
      // We'll use "earliest merge wins" by reversing to learned order.
      if (!state) return [];

      const mode = modeEl.value;
      const words = (mode === "char")
        ? [text]
        : text.toLowerCase().split(/\s+/g).filter(Boolean);

      const mergeOrder = [...state.merges].reverse(); // earliest first
      const mergeRank = new Map();
      for (let i = 0; i < mergeOrder.length; i++) mergeRank.set(pairKey(mergeOrder[i].a, mergeOrder[i].b), i);

      const results = [];

      for (const w of words) {
        let symbols = (mode === "char")
          ? [...Array.from(w), "</w>"]
          : toInitialWordSymbols(w);

        while (true) {
          // find all adjacent pairs and choose the one with the best (lowest) rank
          let best = null;
          let bestRank = Infinity;

          for (let i = 0; i < symbols.length - 1; i++) {
            const k = pairKey(symbols[i], symbols[i + 1]);
            if (!mergeRank.has(k)) continue;
            const r = mergeRank.get(k);
            if (r < bestRank) {
              bestRank = r;
              best = { a: symbols[i], b: symbols[i + 1], merged: symbols[i] + symbols[i + 1] };
            }
          }

          if (!best) break;
          symbols = mergePairInSymbols(symbols, best.a, best.b, best.merged);
        }

        // Remove end-of-word marker in display
        const cleaned = symbols.filter(s => s !== "</w>");
        results.push(...cleaned);

        // Add a visual separator between words (optional)
        if (mode !== "char") results.push("▁"); // like SentencePiece-ish separator (teaching)
      }

      if (mode !== "char" && results.length && results[results.length - 1] === "▁") results.pop();
      return results;
    }

    function renderTokens(tokens) {
      if (!tokens.length) {
        tokensBox.textContent = "—";
        return;
      }
      tokensBox.innerHTML = "";
      for (const t of tokens) {
        const span = document.createElement("span");
        span.className = "tokenSpan";
        span.textContent = t;
        tokensBox.appendChild(span);
      }
    }

    function render() {
      if (!state) {
        statusEl.textContent = "Not initialized";
        vocabPill.textContent = "vocab=—";
        mergePill.textContent = "merges=—";
        renderPairs();
        renderMerges();
        renderVocab();
        tokenizeBtn.disabled = true;
        return;
      }

      const vocab = getVocabularySnapshot(1000000); // set size
      statusEl.textContent = `Initialized • steps=${state.steps} • words=${state.words.length}`;
      vocabPill.textContent = `vocab≈${vocab.length}`;
      mergePill.textContent = `merges=${state.merges.length}`;

      renderPairs();
      renderMerges();
      renderVocab();

      tokenizeBtn.disabled = false;
      const q = queryEl.value.trim();
      if (q) renderTokens(tokenizeWithCurrentMerges(q));
      else tokensBox.textContent = "—";
    }

    function initialize() {
      stopAuto();
      const text = normalizeText(corpusEl.value);
      const mode = modeEl.value;

      const words = buildTrainingWords(text, mode);
      state = {
        words,
        merges: [],
        steps: 0
      };

      explainBox.textContent =
        "Initialized: each word is split into characters + </w> (end-of-word marker). Now you can merge frequent adjacent pairs.";

      stepBtn.disabled = false;
      autoBtn.disabled = false;
      stopBtn.disabled = true;
      tokenizeBtn.disabled = false;

      render();
    }

    function startAuto() {
      if (!state) return;
      stopAuto();
      stepBtn.disabled = true;
      autoBtn.disabled = true;
      stopBtn.disabled = false;

      timer = setInterval(() => {
        stepOnce();
        if (!state) stopAuto();
      }, 350);
    }

    function stopAuto() {
      if (timer) clearInterval(timer);
      timer = null;
      stepBtn.disabled = !state;
      autoBtn.disabled = !state;
      stopBtn.disabled = true;
    }

    // File load
    let loadedFileText = "";

    function enableFile(ok) {
      replaceFileBtn.disabled = !ok;
    }

    fileInput.onchange = async () => {
      const f = fileInput.files?.[0];
      if (!f) { loadedFileText = ""; enableFile(false); return; }
      try {
        loadedFileText = await f.text();
        enableFile(true);
      } catch {
        loadedFileText = "";
        enableFile(false);
      }
    };

    replaceFileBtn.onclick = () => {
      if (!loadedFileText) return;
      corpusEl.value = loadedFileText;
      loadedFileText = "";
      fileInput.value = "";
      enableFile(false);
      // keep state as-is until Initialize is pressed again
    };

    // Wiring
    initBtn.onclick = initialize;
    stepBtn.onclick = stepOnce;
    autoBtn.onclick = startAuto;
    stopBtn.onclick = stopAuto;

    resetBtn.onclick = () => {
      stopAuto();
      state = null;
      corpusEl.value = defaultCorpus();
      queryEl.value = "teaching tokenization is fun";
      explainBox.textContent = "Initialize to start.";
      tokensBox.textContent = "—";
      statusEl.textContent = "Not initialized";
      stepBtn.disabled = true;
      autoBtn.disabled = true;
      stopBtn.disabled = true;
      tokenizeBtn.disabled = true;
      render();
    };

    tokenizeBtn.onclick = () => {
      if (!state) return;
      render();
    };

    queryEl.oninput = () => {
      if (!state) return;
      render();
    };

    modeEl.onchange = () => {
      // changing mode requires re-initialize for consistent training representation
      state = null;
      stopAuto();
      stepBtn.disabled = true;
      autoBtn.disabled = true;
      stopBtn.disabled = true;
      tokenizeBtn.disabled = true;
      explainBox.textContent = "Mode changed. Click Initialize again to rebuild training state.";
      render();
    };

    maxStepsEl.onchange = () => {};
    minCountEl.onchange = () => {};

    // Init
    corpusEl.value = defaultCorpus();
    queryEl.value = "teaching tokenization is fun";
    render();
  </script>
</body>
</html>
